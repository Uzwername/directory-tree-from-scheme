#!/usr/bin/env node

(()=>{"use strict";var e={n:r=>{var t=r&&r.__esModule?()=>r.default:()=>r;return e.d(t,{a:t}),t},d:(r,t)=>{for(var s in t)e.o(t,s)&&!e.o(r,s)&&Object.defineProperty(r,s,{enumerable:!0,get:t[s]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r)},r={};((e,r,t)=>{require("core-js/modules/es.string.trim.js"),require("core-js/modules/es.symbol.description.js"),require("core-js/modules/es.promise.js");const s=require("yargs/yargs");var a=t.n(s);const i=require("yargs/helpers"),n=JSON.parse('{"u2":"mkdir-tree","i8":"1.2.0","WL":"Generate directory tree from a scheme."}'),o=require("path");var c=t.n(o);require("core-js/modules/es.array.iterator.js"),require("core-js/modules/es.regexp.exec.js"),require("core-js/modules/es.string.replace.js"),require("core-js/modules/es.regexp.constructor.js");const l=require("os");var p=t.n(l);const u=new RegExp(`\\s\\/(${["file","dir"].join("|")})$`),h=Object.freeze({pattern:/\|\s/,length:2}),d=(require("core-js/modules/es.array.flat-map.js"),require("core-js/modules/es.array.unscopables.flat-map.js"),require("fs"));var m=t.n(d);const y=require("util");var f=t.n(y);const g=f().promisify(m().open),w=f().promisify(m().close),j=f().promisify(m().mkdir),v=async(e,r)=>{if(!r.length)return[];const t=r.map((async r=>{const t=c().join(e,r.relativePath);try{return"file"===r.type?await(async e=>{const r=await g(e,"a");try{await w(r)}catch(e){}})(t):await(async e=>{try{await j(e)}catch(e){if("EEXIST"===(null==e?void 0:e.code))return;throw e}})(t),{path:t,status:"success",dirent:r}}catch(e){return{path:t,status:"error",dirent:r,error:e}}})),s=await Promise.all(t);return[].concat(s,await v(e,s.filter((e=>"success"===e.status)).flatMap((e=>e.dirent.children))))},q=(e,r)=>{if("string"!=typeof e)throw new TypeError(`Directory path must be a string, passed path's type was ${typeof e}.`);if(0>=e.length)throw new Error("Empty string cannot be used as a directory path.");if("string"!=typeof r)throw new TypeError(`Scheme must be a string, passed scheme's type was ${typeof r}.`);if(!r.length)return[];const t=c().resolve(e),s=(e=>{if(!e||"string"!=typeof e)return[];const r=e.split(p().EOL).reduce(((e,r)=>{const t=r.trim();return t?e.concat(t):e}),[]);let t=[{depth:-1,relativePath:"",parentRef:[]}];const s=()=>t[t.length-1];for(const e of r){let r;const a=e.search(h.pattern);let i;a>-1?(i=e.slice(0,a).replace(/\s/g,""),r=e.slice(a+h.length)):(i="",r=e);const n=i.length,o=e.match(u);let l,p;if(null!==o){const e=o;l=e[0],r=r.slice(0,-l.length),p=e[1]}else p=c().extname(e).length>1?"file":"dir";const d={name:r,type:p,relativePath:"",children:[]};n-s().depth>1||(t=t.filter((({depth:e})=>n>e)),s().parentRef.find((({name:e})=>e===r))||(d.relativePath=c().join(s().relativePath,r),s().parentRef.push(d),"dir"===p&&t.push({depth:n,relativePath:d.relativePath,parentRef:d.children})))}return t[0].parentRef})(r);return v(t,s)},b="Scheme is required.",E="\n$0 (-d|--dir) ./my-project (-s|--scheme) '\ndist\nsrc\n- | constants\n- | utils\n- | views\n- | controllers\n'\n".trim();a()((0,i.hideBin)(process.argv)).scriptName(n.u2).usage(E).command("$0",n.WL,(e=>e.option("dir",{type:"string",alias:"d",default:".",describe:"Path to the target directory where the directory structure specified in the --scheme will be created."}).option("scheme",{type:"string",alias:"s",demand:b,describe:"Graphical description of the directory structure to create."}).check((e=>{if(!e.scheme.length)throw new Error(b);if(!e.dir.length)throw new Error("Empty string cannot be used as a directory path.");return!0}))),(async e=>{try{const r=await q(e.dir,e.scheme),t=r.some((e=>"error"===e.status));process.exitCode=Number(t),t&&console.log(r)}catch(e){console.log(e.message),process.exitCode=1}})).version(n.i8).help().alias("help","h").alias("version","v").argv})(0,0,e),module.exports=r.default})();